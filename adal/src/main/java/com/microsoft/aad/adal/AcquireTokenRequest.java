//  Copyright (c) Microsoft Corporation.
//  All rights reserved.
//
//  This code is licensed under the MIT License.
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files(the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions :
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.

package com.microsoft.aad.adal;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.ContextWrapper;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.support.v4.content.LocalBroadcastManager;
import android.util.SparseArray;

import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.net.URLEncoder;
import java.util.Date;
import java.util.UUID;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Internal class for handling acquireToken logic, including the silent flow and interactive flow.
 */
class AcquireTokenRequest {

    private static final String TAG = AcquireTokenRequest.class.getSimpleName();

    /**
     * Singled threaded Executor for async work.
     */
    private static final ExecutorService sThreadExecutor = Executors.newSingleThreadExecutor();

    /**
     * Delegate map is needed to handle activity recreate without asking
     * developer to handle context instance for config changes.
     */
    static SparseArray<AuthenticationRequestState> mDelegateMap = new SparseArray<>();

    private final Context mContext;
    private final TokenCacheAccessor mTokenCacheAccessor;
    private final boolean mValidateAuthority;
    private final IBrokerProxy mBrokerProxy;

    private final ReentrantReadWriteLock RWL = new ReentrantReadWriteLock();
    private final Lock READ_LOCK = RWL.readLock();
    private final Lock WRITE_LOCK = RWL.writeLock();
    private Handler mHandler = null;
    private BrokerResumeResultReceiver mBrokerResumeResultReceiver = null;
    private boolean mAuthorityValidated = false;

    /*Used for silent request telemetry data logging.*/
    private boolean mAcquireTokenSilentWithBroker = false;

    /**
     * CorrelationId set by user or generated by ADAL.
     */
    private UUID mRequestCorrelationId = null;

        /**
         * Instance validation related calls are serviced inside Discovery as a
         * module.
         */
    private IDiscovery mDiscovery = new Discovery();

    /**
     * Last set authorization callback.
     */
    private AuthenticationCallback<AuthenticationResult> mAuthorizationCallback;

    /**
     * Constructor for {@link AcquireTokenRequest}
     */
    AcquireTokenRequest(final Context context, final boolean valiateAuthority,
                        final TokenCacheAccessor tokenCacheAccessor) {
        mContext = context;
        mValidateAuthority = valiateAuthority;
        mTokenCacheAccessor = tokenCacheAccessor;

        mBrokerProxy = new BrokerProxy(context);
    }

    /**
     * Handles the acquire token logic. Will do authority validation first if developer set valiateAuthority to be
     * true.
     */
    void acquireToken(final IWindowComponent activity, final boolean useDialog, final AuthenticationRequest authRequest,
                      final AuthenticationCallback<AuthenticationResult> authenticationCallback) {
        final CallbackHandler callbackHandle = new CallbackHandler(getHandler(), authenticationCallback);
        // Executes all the calls inside the Runnable to return immediately to
        // user. All UI
        // related actions will be performed using Handler.
        Logger.setCorrelationId(authRequest.getCorrelationId());
        mRequestCorrelationId = authRequest.getCorrelationId();
        Logger.v(TAG, "Sending async task from thread:" + android.os.Process.myTid());
        sThreadExecutor.execute(new Runnable() {
            @Override
            public void run() {
                Logger.v(TAG, "Running task in thread:" + android.os.Process.myTid());
                acquireTokenPreValidation(callbackHandle, authRequest, activity, useDialog, mValidateAuthority);
            }
        });
    }

    /**
     * Developer is using refresh token call to do refresh without cache usage.
     * App context or activity is not needed. Async requests are created, so this
     * needs to be called at UI thread.
     */
    void refreshTokenWithoutCache(final String refreshToken, final String clientId,
                                  final String resource, final String authority,
                                  final AuthenticationCallback<AuthenticationResult> externalCallback) {
        Logger.setCorrelationId(getRequestCorrelationId());
        Logger.v(TAG, "Refresh token without cache");

        if (StringExtensions.IsNullOrBlank(refreshToken)) {
            throw new IllegalArgumentException("Refresh token is not provided");
        }

        if (StringExtensions.IsNullOrBlank(clientId)) {
            throw new IllegalArgumentException("ClientId is not provided");
        }

        if (externalCallback == null) {
            throw new IllegalArgumentException("Callback is not provided");
        }

        final CallbackHandler callbackHandle = new CallbackHandler(getHandler(), externalCallback);

        // Execute all the calls inside Runnable to return immediately. All UI
        // related actions will be performed using Handler.
        sThreadExecutor.execute(new Runnable() {
            @Override
            public void run() {
                final URL authorityUrl = StringExtensions.getUrl(authority);
                if (authorityUrl == null) {
                    callbackHandle.onError(new AuthenticationException(
                            ADALError.DEVELOPER_AUTHORITY_IS_NOT_VALID_URL));

                    return;
                }

                final AuthenticationRequest request = new AuthenticationRequest(authority,
                        resource, clientId, mRequestCorrelationId);

                // It is not using cache and refresh is not expected to
                // show authentication activity.
                request.setSilent(true);
                if (mValidateAuthority) {
                    Logger.v(TAG, "Start authority validation. ");

                    if (validateAuthority(authorityUrl, request.getCorrelationId())) {
                        Logger.v(TAG, "Authority is validated" + authorityUrl.toString());
                    } else {
                        Logger.v(
                                TAG,
                                "Call callback since instance is invalid:"
                                        + authorityUrl.toString());
                        callbackHandle.onError(new AuthenticationException(
                                ADALError.DEVELOPER_AUTHORITY_IS_NOT_VALID_INSTANCE));
                        return;
                    }
                }

                final AuthenticationResult authResult;
                try {
                    final AcquireTokenSilentHandler acquireTokenSilentHandler = new AcquireTokenSilentHandler(mContext,
                            request, mTokenCacheAccessor);
                    authResult = acquireTokenSilentHandler.acquireTokenWithRefreshToken(refreshToken);

                    callbackHandle.onSuccess(authResult);
                } catch (final AuthenticationException authenticationException) {
                    callbackHandle.onError(authenticationException);
                }
            }
        });
    }


    /**
     * Only gets token from activity defined in this package.
     *
     * @param callbackHandle {@link CallbackHandler} used to deliver the result back to
     *                                              the {@link AuthenticationCallback}
     * @param activity {@link Activity} used to start the interactive flow.
     * @param useDialog True if using {@link AuthenticationDialog}, false otherwise.
     * @param  validateAuthority True if needed to perform authority validation, false otherwise.
     * @return {@link AuthenticationResult} for acquireToken flow.
     */
    private AuthenticationResult acquireTokenPreValidation(final CallbackHandler callbackHandle,
                                                           final AuthenticationRequest authenticationRequest,
                                                           final IWindowComponent activity, final boolean useDialog,
                                                           final boolean validateAuthority) {
        final URL authorityUrl = StringExtensions.getUrl(authenticationRequest.getAuthority());
        if (authorityUrl == null) {
            callbackHandle.onError(new AuthenticationException(
                    ADALError.DEVELOPER_AUTHORITY_IS_NOT_VALID_URL));
            return null;
        }

        if (validateAuthority && !mAuthorityValidated) {
            // Discovery call creates an Async Task to send
            // Web Requests
            // using a handler
            boolean result = validateAuthority(authorityUrl, authenticationRequest.getCorrelationId());
            if (result) {
                mAuthorityValidated = true;
                Logger.v(TAG, "Authority is validated: " + authorityUrl.toString());
            } else {
                Logger.v(TAG, "Call external callback since instance is invalid"
                        + authorityUrl.toString());
                callbackHandle.onError(new AuthenticationException(
                        ADALError.DEVELOPER_AUTHORITY_IS_NOT_VALID_INSTANCE));
                return null;
            }
        }

        // Validated the authority or skipped the validation
        try {
            return acquireTokenAfterValidation(callbackHandle, activity, useDialog, authenticationRequest);
        } catch (final AuthenticationException authenticationException) {
            callbackHandle.onError(authenticationException);
            return null;
        }
    }

    /**
     * Perform authority validation.
     * True if the passed in authority is valid, false otherwise.
     */
    private boolean validateAuthority(final URL authorityUrl, final UUID correlationId) {
        // This is not calling outer callback. It is using
        // authenticationCallback, so handler is not needed here
        if (mDiscovery != null) {
            Logger.v(TAG, "Start validating authority");

            // Set CorrelationId for Instance Discovery
            mDiscovery.setCorrelationId(correlationId);
            boolean result = mDiscovery.isValidAuthority(authorityUrl);
            Logger.v(TAG, "Finish validating authority:" + authorityUrl + " result:" + result);
            return result;
        }

        return false;
    }

    /**
     * 1. For Silent flow, we should always try to look local cache first.
     *    i> If valid AT is returned from cache, use it.
     *    ii> If no valid AT is returned, but RT is returned, use the RT.
     *    iii> If RT request fails, and if we can talk to broker, go to broker and check if there is a valid token.
     * 2. For Non-Silent flow.
     *    i> Do silent cache lookup first, same as 1.
     *       a) If we can talk to broker, go to broker for auth.
     *       b) If not, launch webview with embedded flow.
     */
    private AuthenticationResult acquireTokenAfterValidation(CallbackHandler callbackHandle,
                                                             final IWindowComponent activity,
                                                             final boolean useDialog,
                                                             final AuthenticationRequest authenticationRequest)
            throws AuthenticationException {

        AuthenticationResult authenticationResult = null;

        // verify broker redirect uri first
        if (canSwitchToBroker(authenticationRequest) && !authenticationRequest.isSilent()) {
            //check if the redirectUri is valid
            try {
                //the broker redirectUri will be checked only if
                //the request from client App is not silent
                //otherwise the acquiretokensilent might be interrupted
                //by DeveloperAuthenticationException
                if (!authenticationRequest.isSilent()) {
                    verifyBrokerRedirectUri(authenticationRequest);
                }
            } catch (final UsageAuthenticationException exception) {
                Logger.v(TAG, "Did not pass the verification of the broker redirect URI");
                callbackHandle.onError(exception);
                return authenticationResult;
            }
        }

        // For silent request or prompt_behavior is auto, try to look up cache first.
        if (!promptUser(authenticationRequest.getPrompt()) || authenticationRequest.isSilent()) {
            authenticationResult = acquireTokenSilentFlow(authenticationRequest);

            if (isAccessTokenReturned(authenticationResult)) {
                callbackHandle.onSuccess(authenticationResult);
                ClientAnalytics.logEvent(new RefreshTokenEvent(
                        new InstrumentationPropertiesBuilder(authenticationRequest, authenticationResult),
                        InstrumentationIDs.EVENT_RESULT_SUCCESS, mAcquireTokenSilentWithBroker));
            } else {
                // Silent request, if token not returned, return AUTH_REFRESH_FAILED_PROMPT_NOT_ALLOWED back
                // to developer.
                if (authenticationRequest.isSilent()) {
                    // TODO: investigate which server response actually should force user to sign in again
                    // and which error actually should just notify user that some resource require extra steps

                    final String errorInfo = authenticationResult == null ? "" : authenticationResult.getErrorLogInfo();
                    // User does not want to launch activity
                    Logger.e(TAG, "Prompt is not allowed and failed to get token:", authenticationRequest.getLogInfo()
                                    + " " + errorInfo,
                            ADALError.AUTH_REFRESH_FAILED_PROMPT_NOT_ALLOWED);
                    throw new AuthenticationException(
                            ADALError.AUTH_REFRESH_FAILED_PROMPT_NOT_ALLOWED, authenticationRequest.getLogInfo()
                            + " " + errorInfo);

                } else {
                    final boolean isInitialRequest = authenticationResult != null
                            && authenticationResult.isInitialRequest();
                    // Prompt behavior is auto, try to launch webview
                    return acquireTokenInteractiveFlow(callbackHandle, activity, useDialog, isInitialRequest,
                            authenticationRequest);
                }
            }
        } else {
            // For non-silent request or request with prompt behavior as Always, Force_Prompt and refresh_session,
            // launch the webview directly
            return acquireTokenInteractiveFlow(callbackHandle, activity,useDialog, false, authenticationRequest);
        }

        return authenticationResult;
    }

    /**
     * Handles the silent flow. Will always lookup local cache. If there is a valid AT in local cache, will use it. If
     * AT in local cache is already expired, will try RT in the local cache. If RT requst failed, and if we can switch
     * to broker for auth, will switch to broker for authentication.
     */
    private AuthenticationResult acquireTokenSilentFlow(final AuthenticationRequest authenticationRequest)
            throws AuthenticationException {
        AuthenticationResult authResult;

        // Always try with local cache first.
        final AcquireTokenSilentHandler acquireTokenSilentHandler = new AcquireTokenSilentHandler(mContext,
                    authenticationRequest, mTokenCacheAccessor);
        try {
            authResult = acquireTokenSilentHandler.getAccessToken();
        } catch (final AuthenticationException authenticationException) {
            ClientAnalytics.logEvent(new RefreshTokenEvent(
                    new InstrumentationPropertiesBuilder(authenticationRequest, authenticationException),
                    InstrumentationIDs.EVENT_RESULT_FAIL));
            throw authenticationException;
        }

        // try with broker if no token is returned but we can switch to broker.
        if (!isAccessTokenReturned(authResult) && canSwitchToBroker(authenticationRequest)) {
            mAcquireTokenSilentWithBroker = true;
            try {
                final AcquireTokenWithBrokerRequest acquireTokenWithBrokerRequest
                        = new AcquireTokenWithBrokerRequest(authenticationRequest, mBrokerProxy);
                authResult =  acquireTokenWithBrokerRequest.acquireTokenWithBrokerSilent();
            } catch (final AuthenticationException authenticationException) {
                ClientAnalytics.logEvent(new RefreshTokenEvent(
                        new InstrumentationPropertiesBuilder(authenticationRequest, authenticationException),
                        InstrumentationIDs.EVENT_RESULT_FAIL, true));
            }
        }

        return authResult;
    }

    /**
     * Handles the acquire token interactive flow. If we can switch to broker, will always launch webview via broker.
     * If we cannot switch to broker, will launch webview locally.
     */
    private AuthenticationResult acquireTokenInteractiveFlow(final CallbackHandler callbackHandle,
                                                             final IWindowComponent activity,
                                                             final boolean useDialog,
                                                             final boolean isInitialRequest,
                                                             final AuthenticationRequest authenticationRequest)
            throws AuthenticationException {

        HttpWebRequest.throwIfNetworkNotAvaliable(mContext);

        mAuthorizationCallback = callbackHandle.callback;
        authenticationRequest.setRequestId(callbackHandle.callback.hashCode());
        putWaitingRequest(callbackHandle.callback.hashCode(),
                new AuthenticationRequestState(callbackHandle.callback.hashCode(), authenticationRequest,
                        callbackHandle.callback));
        if (canSwitchToBroker(authenticationRequest)) {
            // Always go to broker if the sdk can talk to broker for interactive flow
            if (isInitialRequest) {
                Logger.v(TAG, "Initial request to authenticator");
            }

            Logger.v(TAG, "Launch activity for interactive authentication via broker with callback: "
                    + callbackHandle.callback.hashCode());
            final AcquireTokenWithBrokerRequest acquireTokenWithBrokerRequest
                    = new AcquireTokenWithBrokerRequest(authenticationRequest, mBrokerProxy);

            return acquireTokenWithBrokerRequest.acquireTokenWithBrokerInteractively(activity);
        } else {
            Logger.v(TAG, "Starting Authentication Activity for embedded flow. Callback is:"
                    + callbackHandle.callback.hashCode());
            final AcquireTokenInteractiveRequest acquireTokenInteractiveRequest
                    = new AcquireTokenInteractiveRequest(mContext, authenticationRequest, mTokenCacheAccessor);
            if (useDialog) {
                final AuthenticationDialog dialog = new AuthenticationDialog(getHandler(), mContext, this,
                        authenticationRequest);
                acquireTokenInteractiveRequest.acquireToken(activity, dialog);
            } else {
                acquireTokenInteractiveRequest.acquireToken(activity, null);
            }

            return null;
        }
    }

    /**
     * True if the sdk can switch to broker for auth, false otherwise.
     */
    private boolean canSwitchToBroker(final AuthenticationRequest authenticationRequest) {
        return mBrokerProxy.canSwitchToBroker() && mBrokerProxy.verifyUser(authenticationRequest.getLoginHint(),
                authenticationRequest.getUserId());
    }

    /**
     * Check the redirectUri before sending the request.
     * If the redirectUri from the client does not match the valid redirectUri, the client app would not jump
     * to the login page. redirectUri format %PREFIX://%PACKAGE_NAME/%SIGNATURE
     */
    private boolean verifyBrokerRedirectUri(final AuthenticationRequest request) throws UsageAuthenticationException {
        final String methodName = ":verifyBrokerRedirectUri";
        final String inputUri = request.getRedirectUri();
        final String actualUri = getRedirectUriForBroker();

        final String errMsg;
        if (StringExtensions.IsNullOrBlank(inputUri)) {
            errMsg = "The redirectUri is null or blank. "
                    + "so the redirect uri is expected to be:" + actualUri;
            Logger.e(TAG + methodName, errMsg , "", ADALError.DEVELOPER_REDIRECTURI_INVALID);
            throw new UsageAuthenticationException(ADALError.DEVELOPER_REDIRECTURI_INVALID, errMsg);
        } else if (!inputUri.startsWith(AuthenticationConstants.Broker.REDIRECT_PREFIX + "://")) {
            errMsg = "The prefix of the redirect uri does not match the expected value. "
                    + " The valid broker redirect URI prefix: " + AuthenticationConstants.Broker.REDIRECT_PREFIX
                    + " so the redirect uri is expected to be: " + actualUri;
            Logger.e(TAG + methodName, errMsg , "", ADALError.DEVELOPER_REDIRECTURI_INVALID);
            throw new UsageAuthenticationException(ADALError.DEVELOPER_REDIRECTURI_INVALID, errMsg);
        } else {
            try {
                PackageHelper packageHelper = new PackageHelper(mContext);
                String base64URLEncodePackagename = URLEncoder.encode(mContext.getPackageName(), AuthenticationConstants.ENCODING_UTF8);
                String base64URLEncodeSignature = URLEncoder.encode(packageHelper.getCurrentSignatureForPackage(mContext.getPackageName()), AuthenticationConstants.ENCODING_UTF8);
                if (!inputUri.startsWith(AuthenticationConstants.Broker.REDIRECT_PREFIX + "://" + base64URLEncodePackagename + "/")) {
                    errMsg = "The base64 url encoded package name component of the redirect uri does not match the expected value. "
                            + " This apps package name is: " + base64URLEncodePackagename
                            + " so the redirect uri is expected to be: " + actualUri;
                    Logger.e(TAG + methodName, errMsg , "", ADALError.DEVELOPER_REDIRECTURI_INVALID);
                    throw new UsageAuthenticationException(ADALError.DEVELOPER_REDIRECTURI_INVALID, errMsg);
                } else if (!inputUri.equalsIgnoreCase(actualUri)) {
                    errMsg = "The base64 url encoded signature component of the redirect uri does not match the expected value. "
                            + " This apps signature is: " + base64URLEncodeSignature
                            + " so the redirect uri is expected to be: " + actualUri;
                    Logger.e(TAG + methodName, errMsg , "", ADALError.DEVELOPER_REDIRECTURI_INVALID);
                    throw new UsageAuthenticationException(ADALError.DEVELOPER_REDIRECTURI_INVALID, errMsg);
                }
            } catch (final UnsupportedEncodingException e) {
                Logger.e(TAG + methodName, e.getMessage(), "", ADALError.ENCODING_IS_NOT_SUPPORTED, e);
                throw new UsageAuthenticationException(ADALError.ENCODING_IS_NOT_SUPPORTED, "The verifying BrokerRedirectUri "
                        + "process failed because the base64 url encoding is not supported.", e);
            }
        }

        Logger.v(TAG + methodName, "The broker redirect URI is valid: " + inputUri);
        return true;
    }

    /**
     * Get expected redirect Uri for your app to use in broker. You need to
     * register this redirectUri in order to get token from Broker.
     *
     * @return RedirectUri string to use for broker requests.
     */
    String getRedirectUriForBroker() {
        PackageHelper packageHelper = new PackageHelper(mContext);
        String packageName = mContext.getPackageName();

        // First available signature. Applications can be signed with multiple
        // signatures.
        String signatureDigest = packageHelper.getCurrentSignatureForPackage(packageName);
        String redirectUri = PackageHelper.getBrokerRedirectUrl(packageName, signatureDigest);
        Logger.v(TAG, "Broker redirectUri:" + redirectUri + " packagename:" + packageName
                + " signatureDigest:" + signatureDigest);
        return redirectUri;
    }

    /**
     * This method wraps the implementation for onActivityResult at the related
     * Activity class. This method is called at UI thread.
     *
     * @param requestCode Request code provided at the start of the activity.
     * @param resultCode Result code set from the activity.
     * @param data {@link Intent}
     */
    void onActivityResult(final int requestCode, final int resultCode, final Intent data) {
        final String methodName = ":onActivityResult";
        // This is called at UI thread when Activity sets result back.
        // ResultCode is set back from AuthenticationActivity. RequestCode is
        // set when we start the activity for result.
        if (requestCode == AuthenticationConstants.UIRequest.BROWSER_FLOW) {
            getHandler();

            if (data == null) {
                // If data is null, RequestId is unknown. It could not find
                // callback to respond to this request.
                Logger.e(TAG, "onActivityResult BROWSER_FLOW data is null.", "",
                        ADALError.ON_ACTIVITY_RESULT_INTENT_NULL);
            } else {
                Bundle extras = data.getExtras();
                final int requestId = extras.getInt(AuthenticationConstants.Browser.REQUEST_ID);
                final AuthenticationRequestState waitingRequest = getWaitingRequest(requestId);
                if (waitingRequest != null) {
                    Logger.v(TAG, "onActivityResult RequestId:" + requestId);
                } else {
                    Logger.e(TAG, "onActivityResult did not find waiting request for RequestId:"
                            + requestId, "", ADALError.ON_ACTIVITY_RESULT_INTENT_NULL);
                    // There is no matching callback to send error
                    return;
                }

                // Cancel or browser error can use recorded request to figure
                // out original correlationId send with request.
                final String correlationInfo = getCorrelationInfoFromWaitingRequest(waitingRequest);
                if (resultCode == AuthenticationConstants.UIResponse.TOKEN_BROKER_RESPONSE) {
                    final String accessToken = data
                            .getStringExtra(AuthenticationConstants.Broker.ACCOUNT_ACCESS_TOKEN);
                    final String accountName = data
                            .getStringExtra(AuthenticationConstants.Broker.ACCOUNT_NAME);
                    mBrokerProxy.saveAccount(accountName);
                    final long expireTime = data.getLongExtra(
                            AuthenticationConstants.Broker.ACCOUNT_EXPIREDATE, 0);
                    final Date expire = new Date(expireTime);
                    final String idtoken = data.getStringExtra(AuthenticationConstants.Broker.ACCOUNT_IDTOKEN);
                    final String tenantId = data.getStringExtra(AuthenticationConstants.Broker.ACCOUNT_USERINFO_TENANTID);
                    final UserInfo userinfo = UserInfo.getUserInfoFromBrokerResult(data.getExtras());
                    final AuthenticationResult brokerResult = new AuthenticationResult(accessToken, null,
                            expire, false, userinfo, tenantId, idtoken);
                    if (brokerResult.getAccessToken() != null) {
                        waitingRequest.mDelagete.onSuccess(brokerResult);
                    }
                } else if (resultCode == AuthenticationConstants.UIResponse.BROWSER_CODE_CANCEL) {
                    // User cancelled the flow by clicking back button or
                    // activating another activity
                    Logger.v(TAG, "User cancelled the flow RequestId:" + requestId
                            + correlationInfo);
                    waitingRequestOnError(waitingRequest, requestId, new AuthenticationCancelError(
                            "User cancelled the flow RequestId:" + requestId + correlationInfo));
                } else if (resultCode == AuthenticationConstants.UIResponse.BROKER_REQUEST_RESUME) {
                    Logger.v(TAG + methodName, "Device needs to have broker installed, waiting the broker installation. Once "
                            + "broker is installed, request will be resumed and result will be received");

                    //Register the broker resume result receiver with intent filter as broker_request_resume and specific app package name
                    mBrokerResumeResultReceiver = new BrokerResumeResultReceiver();
                    (new ContextWrapper(mContext)).registerReceiver(mBrokerResumeResultReceiver,
                            new IntentFilter(AuthenticationConstants.Broker.BROKER_REQUEST_RESUME
                                    + mContext.getPackageName()), null, mHandler);

                    // Send cancel result back to caller if doesn't receive result from broker within 5 minuites
                    mHandler.postDelayed(new Runnable() {

                        @Override
                        public void run() {
                            if (!mBrokerResumeResultReceiver.isResultReceivedFromBroker()) {
                                Logger.v(TAG + "onActivityResult", "BrokerResumeResultReceiver doesn't receive result from "
                                        + "broker within 10 minuites, unregister the receiver and cancelling the request");

                                (new ContextWrapper(mContext)).unregisterReceiver(mBrokerResumeResultReceiver);
                                waitingRequestOnError(waitingRequest, requestId, new AuthenticationCancelError("Broker doesn't "
                                        + "return back the result within 10 minuites"));
                            }
                        }
                    }, 10 * 60 * 1000);
                } else if (resultCode == AuthenticationConstants.UIResponse.BROWSER_CODE_AUTHENTICATION_EXCEPTION) {
                    Serializable authException = extras
                            .getSerializable(AuthenticationConstants.Browser.RESPONSE_AUTHENTICATION_EXCEPTION);
                    if (authException != null && authException instanceof AuthenticationException) {
                        AuthenticationException exception = (AuthenticationException)authException;
                        Logger.w(TAG, "Webview returned exception", exception.getMessage(),
                                ADALError.WEBVIEW_RETURNED_AUTHENTICATION_EXCEPTION);
                        waitingRequestOnError(waitingRequest, requestId, exception);
                    } else {
                        waitingRequestOnError(
                                waitingRequest,
                                requestId,
                                new AuthenticationException(
                                        ADALError.WEBVIEW_RETURNED_INVALID_AUTHENTICATION_EXCEPTION, correlationInfo));
                    }
                } else if (resultCode == AuthenticationConstants.UIResponse.BROWSER_CODE_ERROR) {
                    String errCode = extras
                            .getString(AuthenticationConstants.Browser.RESPONSE_ERROR_CODE);
                    String errMessage = extras
                            .getString(AuthenticationConstants.Browser.RESPONSE_ERROR_MESSAGE);
                    Logger.v(TAG, "Error info:" + errCode + " " + errMessage + " for requestId: "
                            + requestId + correlationInfo);
                    waitingRequestOnError(waitingRequest, requestId, new AuthenticationException(
                            ADALError.SERVER_INVALID_REQUEST, errCode + " " + errMessage + correlationInfo));
                } else if (resultCode == AuthenticationConstants.UIResponse.BROWSER_CODE_COMPLETE) {
                    final AuthenticationRequest authenticationRequest = (AuthenticationRequest) extras
                            .getSerializable(AuthenticationConstants.Browser.RESPONSE_REQUEST_INFO);
                    final String endingUrl = extras
                            .getString(AuthenticationConstants.Browser.RESPONSE_FINAL_URL, "");
                    if (endingUrl.isEmpty()) {
                        AuthenticationException e = new AuthenticationException(
                                ADALError.WEBVIEW_RETURNED_EMPTY_REDIRECT_URL,
                                "Webview did not reach the redirectUrl. "
                                        + authenticationRequest.getLogInfo() + correlationInfo);
                        Logger.e(TAG, e.getMessage(), "", e.getCode());
                        waitingRequestOnError(waitingRequest, requestId, e);
                    } else {
                        // Browser has the url and it will exchange auth code
                        // for token
                        final CallbackHandler callbackHandle = new CallbackHandler(mHandler,
                                waitingRequest.mDelagete);

                        // Executes all the calls inside the Runnable to return
                        // immediately to
                        // UI thread. All UI
                        // related actions will be performed using the Handler.
                        sThreadExecutor.execute(new Runnable() {

                            @Override
                            public void run() {
                                try {
                                    final AcquireTokenInteractiveRequest acquireTokenInteractiveRequest
                                            = new AcquireTokenInteractiveRequest(mContext, waitingRequest.mRequest,
                                            mTokenCacheAccessor);
                                    final AuthenticationResult authenticationResult
                                            = acquireTokenInteractiveRequest.acquireTokenWithAuthCode(endingUrl);

                                    if (waitingRequest != null && waitingRequest.mDelagete != null) {
                                        Logger.v(TAG, "Sending result to callback. "
                                                + authenticationRequest.getLogInfo());
                                        callbackHandle.onSuccess(authenticationResult);
                                    }
                                } catch (final AuthenticationException authenticationException) {
                                    final StringBuilder message
                                            = new StringBuilder(authenticationException.getMessage());
                                    if (authenticationException.getCause() != null) {
                                        message.append(authenticationException.getCause().getMessage());
                                    }

                                    Logger.e(TAG, message.toString(),
                                            ExceptionExtensions.getExceptionMessage(authenticationException),
                                            ADALError.AUTHORIZATION_CODE_NOT_EXCHANGED_FOR_TOKEN,
                                            authenticationException);
                                    waitingRequestOnError(callbackHandle, waitingRequest, requestId,
                                            authenticationException);
                                }
                            }
                        });
                    }
                }
            }
        }
    }

    /**
     * FORCE_PROMPT will force broker with PRT support to prompt user.
     */
    private boolean promptUser(PromptBehavior prompt) {
        return prompt == PromptBehavior.Always
                || prompt == PromptBehavior.REFRESH_SESSION
                || prompt == PromptBehavior.FORCE_PROMPT;
    }

    private boolean isAccessTokenReturned(final AuthenticationResult authResult) {
        return authResult != null && !StringExtensions.IsNullOrBlank(authResult.getAccessToken());
    }

    private synchronized Handler getHandler() {
        if (mHandler == null) {
            // Use current main looper
            mHandler = new Handler(mContext.getMainLooper());
        }

        return mHandler;
    }

    /**
     * If request has correlationID, ADAL should report that instead of current
     * CorrelationId.
     *
     * @param waitingRequest
     * @return
     */
    private String getCorrelationInfoFromWaitingRequest(final AuthenticationRequestState waitingRequest) {
        UUID requestCorrelationID = getRequestCorrelationId();
        if (waitingRequest.mRequest != null) {
            requestCorrelationID = waitingRequest.mRequest.getCorrelationId();
        }

        String correlationInfo = String.format(" CorrelationId: %s",
                requestCorrelationID.toString());
        return correlationInfo;
    }

    /**
     * Get the CorrelationId set by user.
     *
     * @return UUID
     */
    UUID getRequestCorrelationId() {
        if (mRequestCorrelationId == null) {
            return UUID.randomUUID();
        }

        return mRequestCorrelationId;
    }

    private void waitingRequestOnError(final AuthenticationRequestState waitingRequest,
                                       int requestId, AuthenticationException exc) {
        if (waitingRequest != null && waitingRequest.mDelagete != null) {
            Logger.v(TAG, "Sending error to callback"
                    + getCorrelationInfoFromWaitingRequest(waitingRequest));
            waitingRequest.mDelagete.onError(exc);
        }
        if (exc != null && exc.getCode() != ADALError.AUTH_FAILED_CANCELLED) {
            removeWaitingRequest(requestId);
        }
    }

    private void waitingRequestOnError(final CallbackHandler handler, final AuthenticationRequestState waitingRequest,
                                       final int requestId, final AuthenticationException exc) {

        if (waitingRequest != null && waitingRequest.mDelagete != null) {
            Logger.v(TAG, "Sending error to callback"
                    + getCorrelationInfoFromWaitingRequest(waitingRequest));
            handler.onError(exc);
        }
        if (exc != null && exc.getCode() != ADALError.AUTH_FAILED_CANCELLED) {
            removeWaitingRequest(requestId);
        }
    }

    private void removeWaitingRequest(int requestId) {
        Logger.v(TAG, "Remove waiting request: " + requestId);

        WRITE_LOCK.lock();
        try {
            mDelegateMap.remove(requestId);
        } finally {
            WRITE_LOCK.unlock();
        }
    }

    private AuthenticationRequestState getWaitingRequest(final int requestId) {
        Logger.v(TAG, "Get waiting request: " + requestId);
        AuthenticationRequestState request = null;

        READ_LOCK.lock();
        try {
            request = mDelegateMap.get(requestId);
        } finally {
            READ_LOCK.unlock();
        }

        if (request == null && mAuthorizationCallback != null
                && requestId == mAuthorizationCallback.hashCode()) {
            // it does not have the caller callback. It will check the last
            // callback if set
            Logger.e(TAG, "Request callback is not available for requestid:" + requestId
                    + ". It will use last callback.", "", ADALError.CALLBACK_IS_NOT_FOUND);
            request = new AuthenticationRequestState(0, null, mAuthorizationCallback);
        }

        return request;
    }

    private void putWaitingRequest(final int requestId, final AuthenticationRequestState requestState) {
        Logger.v(TAG, "Put waiting request: " + requestId
                + getCorrelationInfoFromWaitingRequest(requestState));
        if (requestState != null) {
            WRITE_LOCK.lock();

            try {
                mDelegateMap.put(requestId, requestState);
            } finally {
                WRITE_LOCK.unlock();
            }
        }
    }

    /**
     * Active authentication activity can be cancelled if it exists. It may not
     * be cancelled if activity is not launched yet. RequestId is the hashcode
     * of your AuthenticationCallback.
     *
     * @param requestId Hash code value of your callback to cancel activity
     *            launch
     * @return true: if there is a valid waiting request and cancel message send
     *         successfully. false: Request does not exist or cancel message not
     *         send
     */
    boolean cancelAuthenticationActivity(final int requestId) {

       final  AuthenticationRequestState request = getWaitingRequest(requestId);

        if (request == null || request.mDelagete == null) {
            // there is not any waiting callback
            Logger.v(TAG, "Current callback is empty. There is not any active authentication.");
            return true;
        }

        final String currentCorrelationInfo = getCorrelationInfoFromWaitingRequest(request);
        Logger.v(TAG, "Current callback is not empty. There is an active authentication Activity."
                + currentCorrelationInfo);

        // intent to cancel. Authentication activity registers for this message
        // at onCreate event.
        final Intent intent = new Intent(AuthenticationConstants.Browser.ACTION_CANCEL);
        final Bundle extras = new Bundle();
        intent.putExtras(extras);
        intent.putExtra(AuthenticationConstants.Browser.REQUEST_ID, requestId);
        // send intent to cancel any active authentication activity.
        // it may not cancel it, if activity takes some time to launch.

        final boolean cancelResult = LocalBroadcastManager.getInstance(mContext).sendBroadcast(intent);
        if (cancelResult) {
            // clear callback if broadcast message was successful
            Logger.v(TAG, "Cancel broadcast message was successful." + currentCorrelationInfo);
            request.mCancelled = true;
            request.mDelagete.onError(new AuthenticationCancelError(
                    "Cancel broadcast message was successful."));
        } else {
            // Activity is not launched yet or receiver is not registered
            Logger.w(TAG, "Cancel broadcast message was not successful." + currentCorrelationInfo,
                    "", ADALError.BROADCAST_CANCEL_NOT_SUCCESSFUL);
        }

        return cancelResult;
    }

    private static class CallbackHandler {
        private Handler mRefHandler;

        private AuthenticationCallback<AuthenticationResult> callback;

        public CallbackHandler(Handler ref, AuthenticationCallback<AuthenticationResult> callbackExt) {
            mRefHandler = ref;
            callback = callbackExt;
        }

        public void onError(final AuthenticationException e) {
            if (callback != null) {
                if (mRefHandler != null) {
                    mRefHandler.post(new Runnable() {
                        @Override
                        public void run() {
                            callback.onError(e);
                        }
                    });
                } else {
                    callback.onError(e);
                }
            }
        }

        public void onSuccess(final AuthenticationResult result) {
            if (callback != null) {
                if (mRefHandler != null) {
                    mRefHandler.post(new Runnable() {
                        @Override
                        public void run() {
                            callback.onSuccess(result);
                        }
                    });
                } else {
                    callback.onSuccess(result);
                }
            }
        }
    }

    /**
     * Responsible for receiving message from broker indicating the broker has completed the token acquisition.
     */
    protected class BrokerResumeResultReceiver extends BroadcastReceiver {
        public BrokerResumeResultReceiver() {}

        private boolean receivedResultFromBroker = false;

        @Override
        public void onReceive(Context context, Intent intent) {
            final String methodName = ":BrokerResumeResultReceiver:onReceive";
            Logger.d(TAG + methodName, "Received result from broker.");
            final int receivedWaitingRequestId = intent.getIntExtra(AuthenticationConstants.Browser.REQUEST_ID, 0);

            if (receivedWaitingRequestId == 0) {
                Logger.v(TAG + methodName, "Received waiting request is 0, error will be thrown, cannot find correct "
                        + "callback to send back the result.");
                // Cannot throw AuthenticationException which no longer
                // extending from RuntimeException. Will log the error
                // and return back to caller.
                return;
            }

            // Setting flag to show that receiver already receive result from broker
            receivedResultFromBroker = true;
            final AuthenticationRequestState waitingRequest = getWaitingRequest(receivedWaitingRequestId);

            final String errorCode = intent.getStringExtra(AuthenticationConstants.Browser.RESPONSE_ERROR_CODE);
            if (!StringExtensions.IsNullOrBlank(errorCode)) {
                final String errorMessage = intent.getStringExtra(AuthenticationConstants.Browser.RESPONSE_ERROR_MESSAGE);
                final String returnedErrorMessage = "ErrorCode: " + errorCode + " ErrorMessage" + errorMessage + getCorrelationInfoFromWaitingRequest(waitingRequest);
                Logger.v(TAG + methodName, returnedErrorMessage);
                waitingRequestOnError(waitingRequest, receivedWaitingRequestId, new AuthenticationException(ADALError.AUTH_FAILED, returnedErrorMessage));
            } else {
                final boolean isBrokerCompleteTokenRequest = intent.getBooleanExtra(AuthenticationConstants.Broker.BROKER_RESULT_RETURNED, false);
                if (isBrokerCompleteTokenRequest) {
                    Logger.v(TAG + methodName, "Broker already completed the token request, calling acquireTokenSilentSync to retrieve token from broker.");
                    final AuthenticationRequest authenticationRequest = waitingRequest.mRequest;
                    String userId = intent.getStringExtra(AuthenticationConstants.Broker.ACCOUNT_USERINFO_USERID);

                    // For acquireTokenSilentSync, uniqueId should be passed.
                    if (StringExtensions.IsNullOrBlank(userId)) {
                        userId = authenticationRequest.getUserId();
                    }

                    authenticationRequest.setSilent(true);
                    authenticationRequest.setUserId(userId);
                    authenticationRequest.setUserIdentifierType(AuthenticationRequest.UserIdentifierType.UniqueId);
                    acquireToken(null, false, authenticationRequest, waitingRequest.mDelagete);
                } else {
                    Logger.v(TAG + methodName, "Broker doesn't send back error nor the completion notification.");
                    waitingRequestOnError(waitingRequest, receivedWaitingRequestId,
                            new AuthenticationException(ADALError.AUTH_FAILED,
                                    "Broker doesn't send back error nor the completion notification."));
                }
            }
            (new ContextWrapper(mContext)).unregisterReceiver(mBrokerResumeResultReceiver);
        }

        public boolean isResultReceivedFromBroker() {
            return receivedResultFromBroker;
        }
    }

    private static class RefreshTokenEvent extends ClientAnalytics.Event {

        private RefreshTokenEvent(InstrumentationPropertiesBuilder builder, String result) {
            this(builder, result, false);
        }

        private RefreshTokenEvent(InstrumentationPropertiesBuilder builder, String result, boolean isBroker) {
            super(InstrumentationIDs.REFRESH_TOKEN_EVENT,
                    builder.add(InstrumentationIDs.EVENT_RESULT, result)
                            .add(InstrumentationIDs.IS_BROKER_APP, Boolean.valueOf(isBroker).toString())
                            .build());
        }
    }
}
